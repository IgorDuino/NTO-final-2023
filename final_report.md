# НТО 2023 команда CupTeam
все файлы можно найти на GitHub репозитории - https://github.com/IgorDuino/NTO-final-2023
## Выполнили
Команда "**CupTeam**":
- Андрей Михайлов
- Игорь Кузьменков
- Григорий Муравенко 
- Федор Авдеев
## Содержание

## 1-й Этап Наступательная безопасность
### Web 1
При заполнении формы сервис не делает никаких HTTP запросов, а отправляет данные через WebSocket. В script.js замечаем функции шифрования и дешифрования данных.

Скрипт для отправки запросов через websockets
Файл - web/web1.py

Заметим, что при отправке данных сервис передаёт поле format со значением JSON. Пробуем изменить формат и видим, что сервис принимает формат xml. Используем самую известную уязвимость в этом формате - XXE.
payload:
```jsx=
encrypted({format: 'xml', data: '<!--?xml version="1.0" ?--><!DOCTYPE foo [<!ENTITY example SYSTEM "file:///flag.txt"> ]><data><countries></countries><startdate></startdate><enddate></enddate><resttype></resttype>&example;</data>'})
```
Получаем ответ от сервера:
```json=
{"data":"7J0Yjfd4HIECsHrCT9erTjJhqOz0Kz24L13CC36rwiJv44NtLkbxjPniJoxra5UgjbMvv6qP0wjQsmEvKsMZvIfMB/Sf7fA1o8uzBzoEyEgktphW8lg4wx+8SrmxyRp8rhcTidats8+FSaC067MF8EDIv2b9h+TuTJHQIzvrttzVuCdq3BT9SxXYhksSnILvXRsC0ADIizCQjd9xiCKCmDd2lq/dxcgKjbJXtyVn5xiEFBJaJiUHgyqTExnWAGpQtcFzKnqFosyE54B44CARwcox6FsHSsS1i0DE7pgIn97ju0qmzMWlyrWc8XG743csGOAPGvxpDatC+j4dXehDgq8flj96YArQhOtYrieMTpg4q3X/VfQurnFVNAvl8p/wR8aYoWxzZHkZsGJAWxF2s6b4qJovxhksl/tS/1uX1DY="}
```
Используем функцию decrypted и получаем флаг

### Web 2
В данном отрезке кода видна уязвимость CRLF. Изменяя username мы можем использовать \r - возврат коретки и \n - перенос строки, чтобы поломать запрос. Если запрос поломан сервер отвечает ошибкой с телом запроса, в котором мы видим флаг из-за переноса строки. 
![](https://i.imgur.com/35JmD2N.png)


Эксплойт:

Файл - web/web2.py

### Crypto 1

Можно заметить, что при шифровании (вызове функции dihedral.hash) каждый байт преобразуется независимо не других. Поэтому мы можем прогнать алгоритм по всем байтам и, сопоставляя полученные данные с файлом флага, определить сам флаг

Определили:

Файл - crypto/crypto1.1.py


И сопоставили:

Файл - crypto/crypto1.2.py


### Crypto 2
Заметим, что отправив большое колличество запросов с указанием одного индекса мы можем быть однозначны уверены в его содержании по тому факту, ответил ли сервер числом меньшим, чем половина от n, хотя бы на один запрос.
Так как решение частично зависит от случайности то есть маленькая вероятность, что эксплоит придёться перезапустить несколько раз.

Эксплоит crypto/crypto2.py

### Crypto 3

Первое, что можно найти в интернете, это алгоритм Pohlig-Hellman. Который позволяет взломать алгоритм Диффи-Хелмана, если $p - 1$ раскладывается на небольшие множители. Но в нашем случае у $p - 1$ есть большой нераскладываемый множитель
![](https://i.imgur.com/j56kWaU.png)
Тогда, углубившись в сам алгоритм Pohlig-Hellman, мы пришли к выводу, что достаточно узнать, с чем сравним $flag$ по разным модулям. Узнав достаточно подобных сравнений, мы, не без помощи китайский коллег, смогли восстановить сам $flag$

Скрипт, решающий эту задачу, получает $p$ и shared_flag, расскладывает $p - 1$ на небольшие множители. Через Pohlig-Hellman ищет сравнения по модулям (простым множителям $p - 1$). И через **КТО** получает изначальный $flag$

Файл - crypto/crypto3.1.py

Эта часть программы выводит пары чисел $(r, m)$ таких, что $flag \equiv r \mod\ m$. Далее мы убираем те пары, где $r = 0$, и смотрим, чтобы все модули были взаимнопростыми (на глаз). Далее запускаем скрипт, реализующий Китайскую Теорему об Остатках, и получаем число. Переводим его в шестнацеричную с/с, используем unhex и получаем флаг

Обработка полученных результатов:

Файл - crypto/crypto3.2.py

**КТО**:

Файл - crypto/crypto3.3.py

![](https://i.imgur.com/ElTeEje.png)

## 2-й Этап Расследование инцидента
### Linux

После запуска виртуальной машины на Ubuntu, мы видим окно аутентификации. Так как пароля у нас нету, мы его сбросили через Grub.

![](https://i.imgur.com/oed9RyE.png)
![](https://i.imgur.com/GRl66zm.png)
![](https://i.imgur.com/sjYEwbk.png)
>Сбросили пароль от пользователя sergey

##### 1) Как злоумышленник попал на машину?
После запуска лаунчера Майнкрафта (minecraft.jar), зараженного malware на reverse shell. Сработал payload, который создаёт процесс bash, подключается к серверу злоумышленника по адресу `192.168.126.129:4444` и перенаправляет вход/выход процесса

![](https://i.imgur.com/V2onLt6.png)

##### 2) Как повысил свои права?
На машине мы обнаружили, что исполняемый файл find был с некорректными правами SUID, SGID и владельцем root, что дает возмоэность повысить привилегии до root чем и воспользовался злоумышленник 

Команда: `find . -exec /bin/sh -p \; -quit`
![](https://i.imgur.com/zuvh3Jw.png)


##### 3) Как злоумышленник узнал пароль от passwords.kdbx ?
Злоумышленник установил на ПК жертвы кейлогер(logkeys) и дождался момента, когда пользователь введет пароль от keypass2.

Пароль - `1_D0N7_N0W_WHY_N07_M4Y83_345Y`
![](https://i.imgur.com/ekmXndo.png)


##### 4) Куда logkeys пишет логи ?
Мы убедились, что logkeys записывает логи в файл `/var/log/logkeys.log` по нескольким причинам:
1) Это является стандартным файлом для записи логов, в чем вы убедились из исходников на GitHub logkeys
![](https://i.imgur.com/P6UJRY4.png)
>Стандартный путь на github
2) А так же мы запустили данный бинарный файл через EDB и в динамике, нажимая клавиши увидили, как программа пишет логи в данный файл
![](https://i.imgur.com/45168P9.png)
> edb

##### 5) Пароль от чего лежит в passwords.kdbx?
Открыв keepass2 паролем, который мы нашли выше. Мы увидели пароль от windows_rdp.

Login: `Administrator`
Password: `SecretP@ss0rdMayby_0rNot&`

![](https://i.imgur.com/OcKeaNU.png)
> Открытый keepass2 с логином и паролем от Windows


### Windows
##### 1) Какой пароль от Ransomware?
Разреверсив VTropia.exe(Ransomware) из linux машины с помощью dnSpy мы поняли, что при старте процесса вируса он генерирует пароль с помощью функции CalculateKey, предварительно расшифровав конфиг с помощью XOR на ключ, состоящий из двух частей

![](https://i.imgur.com/ZHFp8V5.png)
![](https://i.imgur.com/WfjbUgf.png)
![](https://i.imgur.com/63IsEYl.png)

Итоговый пароль - `084b988baa7c8d98cda90c5fe603c560`

#### 2) Какие процессы в системе являются вредоносными?
В системе мы обнаружили 5 вредоносных процессов.Мы поняли, что они вредоносных основываясь на нескольких факторах.

1) Не стандартное расположение файлов в системе
2) Файлы были в автозагрузке системе
3) Если запустить дроппер Doom.exe, они сразу появляются в автозагрузке и директориях
4) В реверсе дроппера Doom как раз 5 программ

##### Antimalware Service Executable 
Лежит тут - C:\Windows
Должен быть путь - C:\Program Files\Windows Defender


##### Host Process for Windows Tasks
Лежит тут -  C:\Users\Administrator\AppData\Roaming
Должен быть тут - C:\Windows\System32

##### Runtime Broker
Лежит тут - C:\Users\Administrator\AppData\Local\Temp
Должен быть тут - C:\Windows\System32

##### Security Health Service
Лежит тут - C:\Users\Administrator
Должен быть тут - C:\Windows\System32

##### Windows Explorer
Лежит тут - C:\ProgramData
Должна быть директория - C:\Windows

Поняли, что данные программы являются вредоносными основываясь на реверсе их через dnSpy + virustotal. В dnSpy мы увидели njrat,с помощью virustotal мы подтвердили, что это njrat

![](https://i.imgur.com/TY1Ulys.png)

#### 3) Как произошла доставка этих вирусов?
Доставка вредоностного ПО произошла после запуска дроппера Doom.exe. Понять что это дроппер можно по реверсу кода. 
![](https://i.imgur.com/NRQiXUF.png)
Он доставил все вредоностные exe в систему(Которые были выше)
![](https://i.imgur.com/tFq9FmJ.png)

#### 4) Чем они были упакованы / обфусцированы?
В ходе реверса вредоносных программ на компьютере, мы увидели следы обфускатора NetReactor
![](https://i.imgur.com/nvsl8gi.png)
Чтобы деобфусцировать код программы, воспользывались программой 'NETReactorSlayer'. И нашли в нем следы njrat. 
![](https://i.imgur.com/Wsmfo8O.png)

В следствии чего все было обусфицировано с помощью NetReactor


#### 5) Как злоумышленник нашел креды от Web-сервиса?
Злоумышленник получил данные от Web-сервиса с помощью менеджера паролей в браузере. 

Чтобы прочитать файлы, которые есть на компьютере, мы написали декриптор. 

декриптор - decryptor.cs
скрипт запуска декриптора на все файлы - decryptor_helper.py

После написания декриптора мы расшифровали все файлы.
Переместив вайлы Auth Login и Auth Login Account в папку данных Google Chrome мы увидели в менеджере паролей логин и пароль от http://10.10.137.110/
![](https://i.imgur.com/2GOLqNz.png)

## 3-й Этап Исправление уязвимостей

#### Получение доступа к любому пользователю
Мы обнаружили, что можно зарегестрировать пользователя с таким же никнеймом / почтой, как у уже зарегестрированного пользователя, что дает возможность изменить почту / пароль любого пользователя и получить доступ к его аккаунту

![](https://i.imgur.com/nLHDpba.png)
> Исправление

#### Множество noSQL инъекций
Исправили noSQLi уязвимости, а так же повысили качество кода заменив во многих местах форматированые строки на синтаксис ORM
Например:
```py
def get_backup(self, bid):
    self.__check_connection()
    
    backup = self.backups.find({"$where": f"this.bid == '{bid}'"}, {'bid':0, '_id':0})
    return backup[0]
```
                                            |
```py
def get_backup(self, bid): self.__check_connection()

    backup = self.backups.find({"bid": bid}, {'bid':0, '_id':0})
    return backup[0]
```
